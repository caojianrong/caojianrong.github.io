<html>
<head>
  <title>react路由</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600986 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="804"/>
<h1>react路由</h1>

<div>
<span><div><div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">一、路由的实现原理：根据URL的改变切换组件</span></font></div><div><span style="font-size: 14pt;">1、控制URL改变:</span></div><ul><li><div><span style="font-size: 14pt;">window.location.hash=''</span></div></li></ul><div><span style="font-size: 14pt;">2、监听URL改变，渲染不同的组件</span></div><ul><li><div><span style="font-size: 14pt;">hash：hashchange</span></div></li><li><div><span style="font-size: 14pt;">history：pushstate</span></div></li></ul><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">二、react-router-dom（react-native   rn  做app）</span></div><div><span style="font-size: 14pt; color: rgb(166, 0, 196); font-weight: bold;">1-3版本：  react-router；</span></div><div><span style="font-size: 14pt; color: rgb(166, 0, 196); font-weight: bold;">4-5版本：  react-router-dom ：做网页的路由</span></div><div><span style="font-size: 14pt; color: rgb(166, 0, 196); font-weight: bold;">                  react-router-native做APP的路由</span></div><div><span style="font-size: 14pt; font-weight: bold;">        </span></div><div><span style="font-size: 14pt; font-weight: bold;">npm install react-router-dom</span></div></div><div><br/></div><div><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">三、路由模式（mode）</span></div><div><span style="font-size: 14pt; font-weight: bold;">1、路由容器：</span></div><ul><li><div><span style="font-size: 12pt;">&lt;HashRouter&gt;：hash路由</span></div></li><li><div><span style="font-size: 12pt;">&lt;BrowserRouter&gt;：历史路由</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">2、控制地址栏改变：</span></div><ul><li><div><span style="font-size: 12pt;">&lt;Link to='/path'&gt;</span></div></li><li><div><span style="font-size: 12pt;">&lt;NavLink to='/path'  activeClassName='red'&gt;</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">3、渲染组件：</span></div><ul><li><div><span style="font-size: 12pt;">&lt;Router path='/匹配路径'   component={渲染组件}&gt;</span></div></li><li><div><span style="font-size: 12pt;">&lt;Router path='/匹配路径'   render={渲染组件}&gt;</span></div></li><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(255, 0, 0); font-weight: bold;">正常的组件内部props里是没有路由对象的；</span></span></div></li><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(255, 0, 0); font-weight: bold;">如果一个组件被Route 里的component    render  children 处理过，该组件的props里就有路由对象</span></span></div></li></ul><div><span style="font-size: 14pt; font-weight: bold;">4、exact：精准匹配（全匹配）  path和url必须完全一致</span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">5、&lt;Switch&gt;：万里挑一，只渲染内部第一个匹配到的组件</span></div><div><span style="font-size: 14pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">6、&lt;Redirect   from=' '   to=' '&gt;：重定向</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16pt;">7、</span><span style="font-size: 14pt;">编程式导航   声明式导航：</span><span style="font-size: 14pt; color: rgb(255, 0, 0);">注意路由对象</span></div><div><font style="font-size: 14pt;"><br/></font></div><div><span style="font-size: 14pt;">8</span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">、路由传参：</span></font></div><div><span style="font-weight: bold; font-size: 12pt;">1）. 动态导航  &lt;Route path='/my/:mid'/&gt;</span></div><ul><li><div><span style="font-size: 12pt;">   在目标组件里的路由对象 match</span></div></li><li><div><span style="font-size: 12pt;">   刷新页面数据依然存在，无法传递数据对象 </span></div></li></ul><div><span style="font-size: 12pt; font-weight: bold;">2）.s</span><span style="font-weight: bold; font-size: 12pt;">tate传参</span></div><ul><li><div><span style="font-size: 12pt;">  histroy.push({pathname:'路径地址',state:{}})</span></div></li><li><div><span style="font-size: 12pt;">  页面刷新后数据丢失，有点是可以传递各种数据 数组对象</span></div></li></ul><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3）.query </span></font></div><ul><li><div><span style="font-size: 12pt;"> histroy.push('/my/123/456?us=123&amp;ps=123')</span></div></li><li><div><span style="font-size: 12pt;"> 页面刷新数据依然保留  数据量有限传递对象数组麻烦 使用数据自己去做解析</span></div></li></ul><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">9、嵌套路由：路由里嵌套路由</span></div><div><span style="font-size: 18.6667px;"><b><font style="color: rgb(255, 0, 0);"><span>    </span>嵌套路由的外层不能使用精准匹配</font></b></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b><font style="font-size: 12pt;">&lt;Route path='/my' render={()=&gt;{</font></b></div><div><b><font style="font-size: 12pt;">  return(</font></b></div><div><b><font style="font-size: 12pt;">    &lt;div&gt;</font></b></div><div><b><font style="font-size: 12pt;">      &lt;Route path='/my/info' component={}&gt;</font></b></div><div><b><font style="font-size: 12pt;">    &lt;/div&gt;</font></b></div><div><b><font style="font-size: 12pt;">  )</font></b></div><div><b><font style="font-size: 12pt;">}}&gt;&lt;/Route&gt;</font></b></div><div style="font-size: 18.6667px;"><b><br/></b></div></div><div><span style="font-size: 14pt; font-weight: bold;">10、withRouter：</span></div><div style="margin-left: 40px;"><span style="font-size: 14pt; font-weight: bold;">是一个高阶组件，可以处理一个组件，给被处理的组件添加路由对象</span></div><div><font style="font-size: 14pt;"><b><br/></b></font></div><div><font style="font-size: 14pt;"><b>11、高阶组件HOC</b></font></div><div><a href="http://note.youdao.com/noteshare?id=24eb39aa32795c8053147f5c6a5bbffd"><font style="font-size: 12pt;">http://note.youdao.com/noteshare?id=24eb39aa32795c8053147f5c6a5bbffd</font></a></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><font style="font-size: 12pt;">高阶组件 本是一个函数 接受一个组件作为参数 返回一个新组件</font></div></li><li><div><font style="font-size: 12pt;">高阶函数 本是一个函数  接受一个函数作为参数 返回一个新的函数</font></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><font style="font-size: 12pt;">被高阶组件处理的组件 一般从props中获取数据</font></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">封装优化</font></div><div><font style="font-size: 12pt;">应用 ： 路由守卫  withrouter  connect  antd Form.create()   </font></div><div><span style="font-size: 16pt;"><br/></span></div><div><span style="font-size: 16pt;"><br/></span></div><div><span style="font-size: 16pt;"><br/></span></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 